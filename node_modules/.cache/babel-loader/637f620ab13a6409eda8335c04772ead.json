{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.endOfRange = endOfRange;\nexports.eventLevels = eventLevels;\nexports.eventSegments = eventSegments;\nexports.inRange = inRange;\nexports.segsOverlap = segsOverlap;\nexports.sortEvents = sortEvents;\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nfunction endOfRange(_ref) {\n  var dateRange = _ref.dateRange,\n      _ref$unit = _ref.unit,\n      unit = _ref$unit === void 0 ? 'day' : _ref$unit,\n      localizer = _ref.localizer;\n  return {\n    first: dateRange[0],\n    last: localizer.add(dateRange[dateRange.length - 1], 1, unit)\n  };\n} // properly calculating segments requires working with dates in\n// the timezone we're working with, so we use the localizer\n\n\nfunction eventSegments(event, range, accessors, localizer) {\n  var _endOfRange = endOfRange({\n    dateRange: range,\n    localizer: localizer\n  }),\n      first = _endOfRange.first,\n      last = _endOfRange.last;\n\n  var slots = localizer.diff(first, last, 'day');\n  var start = localizer.max(localizer.startOf(accessors.start(event), 'day'), first);\n  var end = localizer.min(localizer.ceil(accessors.end(event), 'day'), last);\n  var padding = (0, _findIndex.default)(range, function (x) {\n    return localizer.isSameDate(x, start);\n  });\n  var span = localizer.diff(start, end, 'day');\n  span = Math.min(span, slots); // The segmentOffset is necessary when adjusting for timezones\n  // ahead of the browser timezone\n\n  span = Math.max(span - localizer.segmentOffset, 1);\n  return {\n    event: event,\n    span: span,\n    left: padding + 1,\n    right: Math.max(padding + span, 1)\n  };\n}\n\nfunction eventLevels(rowSegments) {\n  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  var i,\n      j,\n      seg,\n      levels = [],\n      extra = [];\n\n  for (i = 0; i < rowSegments.length; i++) {\n    seg = rowSegments[i];\n\n    for (j = 0; j < levels.length; j++) {\n      if (!segsOverlap(seg, levels[j])) break;\n    }\n\n    if (j >= limit) {\n      extra.push(seg);\n    } else {\n      ;\n      (levels[j] || (levels[j] = [])).push(seg);\n    }\n  }\n\n  for (i = 0; i < levels.length; i++) {\n    levels[i].sort(function (a, b) {\n      return a.left - b.left;\n    }); //eslint-disable-line\n  }\n\n  return {\n    levels: levels,\n    extra: extra\n  };\n}\n\nfunction inRange(e, start, end, accessors, localizer) {\n  var event = {\n    start: accessors.start(e),\n    end: accessors.end(e)\n  };\n  var range = {\n    start: start,\n    end: end\n  };\n  return localizer.inEventRange({\n    event: event,\n    range: range\n  });\n}\n\nfunction segsOverlap(seg, otherSegs) {\n  return otherSegs.some(function (otherSeg) {\n    return otherSeg.left <= seg.right && otherSeg.right >= seg.left;\n  });\n}\n\nfunction sortEvents(eventA, eventB, accessors, localizer) {\n  var evtA = {\n    start: accessors.start(eventA),\n    end: accessors.end(eventA),\n    allDay: accessors.allDay(eventA)\n  };\n  var evtB = {\n    start: accessors.start(eventB),\n    end: accessors.end(eventB),\n    allDay: accessors.allDay(eventB)\n  };\n  return localizer.sortEvents({\n    evtA: evtA,\n    evtB: evtB\n  });\n}","map":{"version":3,"names":["_interopRequireDefault","require","default","Object","defineProperty","exports","value","endOfRange","eventLevels","eventSegments","inRange","segsOverlap","sortEvents","_findIndex","_ref","dateRange","_ref$unit","unit","localizer","first","last","add","length","event","range","accessors","_endOfRange","slots","diff","start","max","startOf","end","min","ceil","padding","x","isSameDate","span","Math","segmentOffset","left","right","rowSegments","limit","arguments","undefined","Infinity","i","j","seg","levels","extra","push","sort","a","b","e","inEventRange","otherSegs","some","otherSeg","eventA","eventB","evtA","allDay","evtB"],"sources":["C:/Users/leandro.wilker/Desktop/WEBLND/app-web-lnd/node_modules/react-big-calendar/lib/utils/eventLevels.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.endOfRange = endOfRange;\nexports.eventLevels = eventLevels;\nexports.eventSegments = eventSegments;\nexports.inRange = inRange;\nexports.segsOverlap = segsOverlap;\nexports.sortEvents = sortEvents;\n\nvar _findIndex = _interopRequireDefault(require(\"lodash/findIndex\"));\n\nfunction endOfRange(_ref) {\n  var dateRange = _ref.dateRange,\n      _ref$unit = _ref.unit,\n      unit = _ref$unit === void 0 ? 'day' : _ref$unit,\n      localizer = _ref.localizer;\n  return {\n    first: dateRange[0],\n    last: localizer.add(dateRange[dateRange.length - 1], 1, unit)\n  };\n} // properly calculating segments requires working with dates in\n// the timezone we're working with, so we use the localizer\n\n\nfunction eventSegments(event, range, accessors, localizer) {\n  var _endOfRange = endOfRange({\n    dateRange: range,\n    localizer: localizer\n  }),\n      first = _endOfRange.first,\n      last = _endOfRange.last;\n\n  var slots = localizer.diff(first, last, 'day');\n  var start = localizer.max(localizer.startOf(accessors.start(event), 'day'), first);\n  var end = localizer.min(localizer.ceil(accessors.end(event), 'day'), last);\n  var padding = (0, _findIndex.default)(range, function (x) {\n    return localizer.isSameDate(x, start);\n  });\n  var span = localizer.diff(start, end, 'day');\n  span = Math.min(span, slots); // The segmentOffset is necessary when adjusting for timezones\n  // ahead of the browser timezone\n\n  span = Math.max(span - localizer.segmentOffset, 1);\n  return {\n    event: event,\n    span: span,\n    left: padding + 1,\n    right: Math.max(padding + span, 1)\n  };\n}\n\nfunction eventLevels(rowSegments) {\n  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;\n  var i,\n      j,\n      seg,\n      levels = [],\n      extra = [];\n\n  for (i = 0; i < rowSegments.length; i++) {\n    seg = rowSegments[i];\n\n    for (j = 0; j < levels.length; j++) {\n      if (!segsOverlap(seg, levels[j])) break;\n    }\n\n    if (j >= limit) {\n      extra.push(seg);\n    } else {\n      ;\n      (levels[j] || (levels[j] = [])).push(seg);\n    }\n  }\n\n  for (i = 0; i < levels.length; i++) {\n    levels[i].sort(function (a, b) {\n      return a.left - b.left;\n    }); //eslint-disable-line\n  }\n\n  return {\n    levels: levels,\n    extra: extra\n  };\n}\n\nfunction inRange(e, start, end, accessors, localizer) {\n  var event = {\n    start: accessors.start(e),\n    end: accessors.end(e)\n  };\n  var range = {\n    start: start,\n    end: end\n  };\n  return localizer.inEventRange({\n    event: event,\n    range: range\n  });\n}\n\nfunction segsOverlap(seg, otherSegs) {\n  return otherSegs.some(function (otherSeg) {\n    return otherSeg.left <= seg.right && otherSeg.right >= seg.left;\n  });\n}\n\nfunction sortEvents(eventA, eventB, accessors, localizer) {\n  var evtA = {\n    start: accessors.start(eventA),\n    end: accessors.end(eventA),\n    allDay: accessors.allDay(eventA)\n  };\n  var evtB = {\n    start: accessors.start(eventB),\n    end: accessors.end(eventB),\n    allDay: accessors.allDay(eventB)\n  };\n  return localizer.sortEvents({\n    evtA: evtA,\n    evtB: evtB\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}